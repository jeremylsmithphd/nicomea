# nicomea
Routines for computing various entropy and fractal measures on a 4-dimensional resting-state NIfTI dataset.

<b>Motivation.</b> Several very useful routines have already been written<sup>[<a href="https://github.com/nikdon">1</a>],[<a href="https://github.com/qgeissmann">2</a>],[<a href="https://github.com/CSchoel">3</a>],[<a href="https://github.com/DominiqueMakowski">4</a>],[<a href="https://github.com/CSchoel">5</a>],[<a href="https://github.com/srk-srinivasan">6</a>]</sup> for 1-D signals such as EEG, but these were not optimized for broadcasting over a 4-D matrix. I can't take credit for the algorithms which do the actual number-crunching here &mdash; I've simply added NIfTI capabilities and tweaked the functions a bit so they can process large datasets in little time. The result is runtimes of ~10 sec (for <code>rs_complexity_shannon</code>) to about 5-7 min (<code>rs_complexity_hurst</code>) on the Emory University CSIC cluster, as opposed to <em>26 hours</em> (!) with Neurokit, which was optimized for EEG signals. However, YMMV.

<b>Dependencies.</b> Runs out-of-the-box on a current scientific Python distribution such as Anaconda. Otherwise, you'll need to ensure that you've installed Nibabel, Nilearn, NumPy, and Scipy.

<b>Usage.</b> With the exception of <code>rs_complexity_matrix</code>, the syntax is just <code>rs_complexity_</code><em>whatever</em><code>(input_nifti, output_filename)</code>. <code>rs_complexity_matrix</code> was written as part of an image processing pipeline and expects the syntax <code>rs_matrix_complexity(input_nifti, tsnr_file, dw_file, output_filename)</code>. I generate the <code>tsnr_file</code> (temporal signal-to-noise ratio) and <code>dw_file</code> (Durbin-Watson) with the AFNI program <code>3dTstat</code>. These two functions, plus a few additional ones, will gradually be added to this repo.

<b>Outputs.</b> Except for <code>rs_complexity_matrix</code>, these routines output NIfTI volumes containing the Hurst exponents, fractal dimension as calculated with the Katz or Petrosian algorithms, or Shannon or spectral entropy. <code>rs_complexity_matrix</code> outputs a NIfTI volume containing all of these but also saves a NumPy matrix <em>outfile</em><code>_matrix.npy</code> for, say, neural networks.
